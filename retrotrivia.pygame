#!/usr/bin/env python
# Simple Quiz Game Engine in PyGame
# for Batocera Retrotrivia
# lbrpdx - 2020-2026
# https://github.com/lbrpdx/retrotrivia
# License: LGPL 3.0
import pygame
import pygame.freetype
import random
import questions
import gamelists
import videoplayer
import os
import sys
import psutil
import logging
import unicodedata
import math
import threading

#######################################
### Global parameters
DEBUG            = 0
TIMER            = 30  # seconds to respond
NUMBER_Q         = 10  # number of questions to ask
PLAYERS          = 1   # default nb of players
SOUND_VOL        = 5   # default volume (0 to 5)
WINDOW_SURFACE   = pygame.HWSURFACE|pygame.DOUBLEBUF
SYS_FONT         = './assets/Bifocals.otf'
FONT             = None
FONT_SIZE        = 40
TEXT_COLOR       = 'black'
TEXT_HALO        = 'cadetblue3'
TEXT_HALO_MENU   = 'plum'
TEXT_HALO_TIMER  = 'white'
BOX_COLOR        = 'blue'
BOX_COLOR_ANSWER = 'green'
BOX_COLOR_WRONG  = 'red'
BOX_WIDTH        = 4
TIMER_COLOR      = 'green'
TIMER_COLOR_END  = 'red'
GAMEMODES_NAMES  = [ 'Video', 'Trivia', 'Pixel', 'Rotate', 'Zoom' ]
GAMEMODES        = [ 1, 1, 1, 1, 1 ]
PLAYERS_MAX      = 4
NUM_QUESTIONS_MAX= 30
TIMER_MAX        = 30
SCREEN           = None
JOYSTICKS        = [ None, None, None, None ]
LOGGER           = logging.getLogger()
AUDIO_FREQ       = 44100
AUDIO_BUFFER     = 4096
VIDEO_EXTENSIONS = [ '.mp4', '.mkv', '.avi', '.m4v' ]
PADS_LAST_AT     = {}


#######################################
class RenderedText:
    def __init__(self, text, color, halo_color, rect, thickness=4, offset=0):
        self.text = self._clean_text(text)
        self.rect = rect
        # Increased default thickness for better visibility
        self.surface = self._render(FONT, color, halo_color, thickness, offset)

    def _clean_text(self, text):
        if isinstance(text, bytes):
            text = text.decode("utf-8")
        return unicodedata.normalize('NFD', text).encode('ascii', 'ignore').decode("utf-8").upper()

    def _render(self, font, color, halo_color, thickness, offset):
        # Handle word wrapping
        processed_text = self.text.replace('\\n', '\n')
        paragraphs = processed_text.split('\n')
        lines = []
        
        for p in paragraphs:
            if p == "":
                lines.append("")
                continue

            words = p.split(' ')
            cur = ""
            for w in words:
                # Calculate width of the line if we add this word
                test_line = cur + w + " "
                if font.get_rect(test_line).width < self.rect.width:
                    cur = test_line
                else:
                    lines.append(cur)
                    cur = w + " "
            lines.append(cur)

        # Setup surface dimensions
        offs = offset * int (SCREEN.get_height()/1080)
        line_height = int(font.get_rect("TgM").height * 1.3)
        total_h = len(lines) * line_height + (thickness * 2) + offs
        final_surf = pygame.Surface((self.rect.width, total_h), pygame.SRCALPHA).convert_alpha()

        for i, line in enumerate(lines):
            # If it's a blank line, we just move the cursor (i)
            # and don't render anything, creating the "skip" effect.
            if line == "" or line.isspace():
                continue
            txt_surf, _ = font.render(line, color)
            halo_surf, _ = font.render(line, halo_color)
            
            y_off = offs + i * line_height + thickness
            
            for dx in range(-thickness, thickness + 1):
                for dy in range(-thickness, thickness + 1):
                    # Skip the corners slightly to keep it rounded, or keep all for a boxy stroke
                    if dx*dx + dy*dy <= thickness*thickness:
                        final_surf.blit(halo_surf, (thickness + dx, y_off + dy))
            
            # Draw the main text over the halo
            final_surf.blit(txt_surf, (thickness, y_off))
            
        return final_surf

#########################################
## Manage sound from multiple objects (otherwise : crash)
class SoundManager:
    def __init__(self):
        self.sound = None
        self.vol   = 0
        self.last  = 0
        pygame.mixer.pre_init(frequency=AUDIO_FREQ, buffer=AUDIO_BUFFER)
        pygame.mixer.init()
        pygame.mixer.init(frequency=AUDIO_FREQ, buffer=AUDIO_BUFFER)

    def volume(self, new_vol):
        self.vol = new_vol

    def wait(self, delay):
        pygame.mixer.music.pause()
        now = pygame.time.get_ticks()
        self.last = now
        while (now - self.last < delay):
            pygame.time.wait(10)
            now = pygame.time.get_ticks()
        pygame.mixer.music.unpause()

    def play(self, sound_file, delay=0):
        if pygame.mixer.get_busy():
            pygame.mixer.music.stop()
        if not os.path.isfile(sound_file):
            return
        if self.vol > 0:
            pygame.mixer.music.load(sound_file)
            pygame.mixer.music.play(0)
            if delay > 0:
                thr = threading.Thread(target=self.wait, args=[delay])
                thr.daemon = True
                thr.start()

#########################################
## log messages to stdout
def log(message):
    global DEBUG
    global LOGGER
    if DEBUG > 0:
        LOGGER.debug(message)

#########################################
## Joystick/pad/keyboard events
def key_pressed(event, joypads):
    global DEBUG
    if (event.type == pygame.KEYDOWN and joypads == None):
        log (f"Keyboard event: {event.key}")
        # Always player 1 for keyboard
        if event.key == pygame.K_UP:
            return (0, 'up')
        elif event.key == pygame.K_LEFT:
            return (0, 'left')
        elif event.key == pygame.K_RIGHT:
            return (0, 'right')
        elif event.key == pygame.K_DOWN:
            return (0, 'down')
        elif event.key in (97, 98):  # A and B keys
            return (0, 'action')
    if joypads == None:
        return (-1, -1) # keyboard/pad2key only, no initialized joypad
    for joypad in joypads:
        if joypad == None:
            continue
        id = joypad.get_instance_id()
        if event.type == pygame.JOYAXISMOTION:  # Analogue Hat
            try:
                if joypad.get_axis(1) <= -1:
                    log(f"Joypad {id}: axis {joypad.get_axis(1)} up")
                    return (id, 'up')
                elif joypad.get_axis(0) <= -1:
                    log(f"Joypad {id}: axis {joypad.get_axis(0)} left")
                    return (id, 'left')
                elif joypad.get_axis(0) >= 0.5:
                    log(f"Joypad {id}: axis {joypad.get_axis(0)} right")
                    return (id, 'right')
                elif joypad.get_axis(1) >= 0.5:
                    log(f"Joypad {id}: axis {joypad.get_axis(1)} down")
                    return (id, 'down')
            except Exception as e:
                    log(f"Joypad {id} error: {e}")
        elif event.type == pygame.JOYHATMOTION:  # Digital Hat
            try:
                log(f"Joypad {id}: hat {joypad.get_hat(0)}")
                if joypad.get_hat(0) == (0,1):
                    return (id, 'up')
                elif joypad.get_hat(0) == (-1,0):
                    return (id, 'left')
                elif joypad.get_hat(0) == (1,0):
                    return (id, 'right')
                elif joypad.get_hat(0) == (0,-1):
                    return (id, 'down')
            except Exception as e:
                    log(f"Joypad {id} error: {e}")
        elif event.type == pygame.JOYBUTTONDOWN:
            if DEBUG > 0:
                for k in range (joypad.get_numbuttons()):
                    if joypad.get_button(k):
                        log (f"Joypad {id}: button {k}")
            try:
                if joypad.get_button(0):  # Buttons A or B
                    return (id, 'action')
                elif joypad.get_button(1):  # Buttons A or B
                    return (id, 'action')
                elif joypad.get_button(8):
                    return (id, 'up')
                elif joypad.get_button(10):
                    return (id, 'left')
                elif joypad.get_button(11):
                    return (id, 'right')
                elif joypad.get_button(9):
                    return (id, 'down')
                elif joypad.get_button(13):
                    return (id, 'up')
                elif joypad.get_button(15):
                    return (id, 'left')
                elif joypad.get_button(16):
                    return (id, 'right')
                elif joypad.get_button(14):
                    return (id, 'down')
                elif joypad.get_button(2):  # Buttons A or B
                    return (id, 'action')
                elif joypad.get_button(3):  # Buttons A or B
                    return (id, 'action')
            except Exception as e:
                    log(f"Joypad {id} error: {e}")
    return (-1, -1) # No event

######################################
### Colorize icon
def colorize_icon(image, color):
    newimage = image.copy()
    newimage.fill((0, 0, 0, 255), None, pygame.BLEND_RGBA_MULT)
    newimage.fill(color[0:3] + (0,), None, pygame.BLEND_RGBA_ADD)
    return newimage

#######################################
### List and types of questions
class QuestionBank:
    triviabank     = []
    videobank      = []
    loaded         = 0          # number of questions loaded
    gamemode       = GAMEMODES  # Also save settings here
    timer          = TIMER
    number_q       = NUMBER_Q
    sound_vol      = SOUND_VOL
    players        = PLAYERS
    timerplayers   = [0, 0, 0, 0]
    loaded_pcent   = 0

    def __init__(self):
        pass

    def load_all(self):
        self.loaded_pcent = 0
        self.triviabank = questions.Q[:]
        self.loaded += len (self.triviabank)
        gl = gamelists.gamelist()
        i = 0
        for sys in gl.systems:
                loaded_sys = gl.load(sys)
                self.videobank += loaded_sys[:]
                i += 1
                self.loaded_pcent = int(100*i/len(gl.systems))
                log(f"Loaded system {sys} with {len(loaded_sys)} games.")
        self.loaded += len (self.videobank)
        log(f"Total questions loaded: {len(self.triviabank)} trivia, {self.loaded} questions including videos")

    def initialize_Q(self):
        thr = threading.Thread(target=self.load_all, args=())
        thr.daemon = True
        thr.start()

#######################################
### Current Game state
class GameState:
    QB = None

    def __init__(self, QB):
        self.current_question   = None
        self.current_mode       = 0
        self.QB                 = QB
        self.questionst         = {}   # trivia questions
        self.questionsv         = {}   # video thumbnails questions
        self.right              = [ 0, 0, 0, 0 ]
        self.wrong              = [ 0, 0, 0, 0 ]
        self.score              = [ 0, 0, 0, 0 ]
        self.numq               = 0     # what question are we at?
        self.numqansw           = 0     # what question have we answered?

    def pop_question(self):
        log ("GameState pop question")
        if len (self.questionst) < (self.QB.number_q - self.numqansw):
            self.questionst = self.QB.triviabank[:]
        # Remind: GAMEMODES_NAMES = [ 'Video', 'Trivia', 'Pixel', 'Rotate', 'Zoom' ]
        if self.QB.gamemode[0] == 1 or self.QB.gamemode[2] == 1 \
                                    or self.QB.gamemode[3] == 1 or self.QB.gamemode[4] == 1:
            if len (self.questionsv) < (self.QB.number_q - self.numqansw):
                self.questionsv = self.QB.videobank[:]
        ntry = 0
        self.current_mode = (self.current_mode+1) % len(GAMEMODES)
        while (ntry < len(self.QB.gamemode) and self.QB.gamemode[self.current_mode] == 0):
            self.current_mode = (self.current_mode+1) % len(GAMEMODES)
            ntry += 1
        if self.QB.gamemode[self.current_mode] == 0:
            self.current_mode = 1 # Force trivia (even if not selected, because nothing else)
        self.numq += 1
        log(f"Question {str(self.numq)} mode {str(self.current_mode)}: ({GAMEMODES_NAMES[self.current_mode]})")
        # Video (normal, pixelated, rotated or zoomed)
        if self.current_mode in [ 0, 2, 3, 4 ]:
                try:
                    q = random.choice(self.questionsv)
                    self.questionsv.remove(q)
                except: # not enough videos
                    q = random.choice(self.questionst)
                    self.questionst.remove(q)
        else:
            q = random.choice(self.questionst)
            self.questionst.remove(q)
        self.current_question = q
        log(f"Question: {str(q)}")
        return q

    def get_answer(self, vinput, timerpl):
        if self.numqansw < self.numq:
            self.numqansw += 1
            ret = False
            for p in range(self.QB.players):
                if vinput[p] == self.current_question[1]:
                    self.right[p] += 1
                    self.score[p] += timerpl[p]
                    log (f"Question {self.numqansw} was right at {timerpl[p]} sec for player {p+1}")
                    ret = True
                else:
                    self.wrong[p] += 1
                    self.score[p] -= timerpl[p]
                    if self.score[p] < 0:
                        self.score[p] = 0 # No negative score, too depressing
                    log (f"Question {self.numqansw} was wrong at {timerpl[p]} sec for player {p+1}")
            return ret

    def get_result(self):
        log ("Game Over")
        res = ""
        if self.QB.players > 1:
            for p in range(self.QB.players):
                res += f"Player {p+1}: {self.score[p]} points\n"
                res += f"  ({self.right[p]} right, {self.wrong[p]} wrong answers)\n"
            res += "\n \nPlayer 1, press [A] to continue"
            return res
        else:
            if self.score[0] > self.QB.number_q * self.QB.timer/2:
                tagline="GREAT SCORE!\n "
            elif self.score[0] > self.QB.number_q:
                tagline="NOT TOO BAD.\n "
            elif self.score[0] > self.QB.number_q/2:
                tagline="YOU CAN DO BETTER NEXT TIME.\n "
            else:
                tagline="OK, WE WON'T JUDGE YOU...\n"
            tright = f"\n{self.right[0]} answers were correct\n" if self.right[0]>1 \
                else f"\nhuh, {self.right[0]} answer was correct\n"
            twrong = f"{self.wrong[0]} answers were wrong" if self.wrong[0]>1 \
                else f"and, wow, {self.wrong[0]} answer was wrong"
            return f"\n \nFINAL SCORE: {self.score[0]}\n" + tagline \
                + tright +twrong + "\n \nPress [A] to continue"


#######################################
### Simple static Screen
class StaticScreen:
    QB = None
    circle_cache = {}

    def __init__(self, next_scene, img, text):
        self.background = pygame.Surface((SCREEN.get_width(), SCREEN.get_height()))
        self.square = int(SCREEN.get_height()/20)
        self.img = img if img else None
        self.additional_text = None
        self.next_scene = next_scene
        self.txt_rendered = []
        self.text_rect = pygame.Rect(SCREEN.get_width()//2.5, SCREEN.get_height()//3,
                                     SCREEN.get_width()//3, SCREEN.get_height()//3 )
        self.loading_text_obj = RenderedText(text, TEXT_COLOR, TEXT_HALO_MENU, self.text_rect)

    def start(self, text):
        opx = 5*SCREEN.get_height()//1080
        self.txt_rendered = [ ]
        self.additional_text = text if text else None
        self.back_img = pygame.image.load('assets/back_cover.jpg')
        self.back_img = pygame.transform.scale(self.back_img, (SCREEN.get_width(), SCREEN.get_height()))
        self.background.blit(self.back_img, (0, 0))
        if self.img:
            self.foreground = pygame.image.load(self.img)
            img_ratio = float(float(self.foreground.get_width())/self.foreground.get_height())
            self.foreground = pygame.transform.scale(self.foreground, (int(SCREEN.get_width()/8*img_ratio),
                        int(SCREEN.get_width()/8)))
            backdrop = colorize_icon(self.foreground.convert_alpha(), pygame.Color(TEXT_HALO_MENU))
            w = backdrop.get_width() + 2 * opx
            h = backdrop.get_height() + 2 * opx
            osurf = pygame.Surface((w, h)).convert_alpha()
            osurf.fill((0, 0, 0, 0))
            surf = osurf.copy()
            osurf.blit(backdrop, (0, 0))
            for dx, dy in circlepoints(opx, self.circle_cache):
                surf.blit(osurf, (dx - opx//2, dy - opx//2))
            surf.blit(backdrop, (opx, opx))
            self.background.blit(surf, (int(SCREEN.get_width()*0.375), int(SCREEN.get_height()/8)))
            self.background.blit(self.foreground, (int(SCREEN.get_width()*0.375), int(SCREEN.get_height()/8)))

        if self.additional_text:
            self.loading_text_obj = RenderedText(self.additional_text, TEXT_COLOR, TEXT_HALO_MENU, self.text_rect)

    def additional(self, text):
        self.loading_text_obj = RenderedText(text, TEXT_COLOR, TEXT_HALO_MENU, self.text_rect)

    def draw(self):
        SCREEN.blit(self.background, (0, 0))
        for i, rendered in enumerate(self.txt_rendered):
            SCREEN.blit(rendered.surface, (rendered.rect.x, rendered.rect.y))
        if self.loading_text_obj:
            SCREEN.blit(self.loading_text_obj.surface,
                    (self.loading_text_obj.rect.x, self.loading_text_obj.rect.y))

    def update(self, events, dt):
        for event in events:
            if key_pressed (event, [JOYSTICKS[0]]) == (0, 'action'):
                return (self.next_scene, None)

    def initialize_QB(self):
        if self.QB == None:
            self.QB = QuestionBank()
            self.QB.initialize_Q()


#######################################
### Settings
class SettingsScreen:
    QB = None

    def __init__(self, QB):
        self.QB = QB
        self.background = pygame.Surface((SCREEN.get_width(), SCREEN.get_height()))
        self.rects_set, self.rects_down, self.rects_val, self.rects_up = [], [], [], []
        x = SCREEN.get_width()//25
        y = SCREEN.get_height()//8
        self.square = int(SCREEN.get_height()/12)
        self.settings = [ 'NUMBER OF QUESTIONS', 'TIME LIMIT', 'SOUND VOLUME', 'PLAYERS', 'GAME MODES' ]
        self.settings_val = [ NUMBER_Q, TIMER, SOUND_VOL, PLAYERS, GAMEMODES[:] ]
        for n in range(4):
            rect_set   = pygame.Rect(x, y, int(SCREEN.get_width()/5+self.square), self.square)
            rect_down  = pygame.Rect(int(x+SCREEN.get_width()/5+self.square*1.5), y, self.square, self.square)
            rect_val   = pygame.Rect(int(x+SCREEN.get_width()/5+self.square*3.0), y, self.square, self.square)
            rect_up    = pygame.Rect(int(x+SCREEN.get_width()/5+self.square*4.5), y, self.square, self.square)
            self.rects_set.append(rect_set)
            self.rects_down.append(rect_down)
            self.rects_val.append(rect_val)
            self.rects_up.append(rect_up)
            y += int(self.square*1.1)
        # Gamemodes (1/2)
        self.rects_gmodes = pygame.Rect(x, y, int(SCREEN.get_width()/5+self.square), self.square)
        self.rects_gmode = []
        self.rects_gmval = []
        for i in range(2):
            self.rects_gmval.append(pygame.Rect(int(x+SCREEN.get_width()/5+self.square*(1.5+3*i)), y, self.square, self.square))
            self.rects_gmode.append(pygame.Rect(int(x+SCREEN.get_width()/5+self.square*(2.5+3*i)), y, 2*self.square, self.square))
        y += int(self.square*1.1)
        for i in range(3):
            self.rects_gmval.append(pygame.Rect(int(x+SCREEN.get_width()/5+self.square*(1.5+3*i)), y, self.square, self.square))
            self.rects_gmode.append(pygame.Rect(int(x+SCREEN.get_width()/5+self.square*(2.5+3*i)), y, 2*self.square, self.square))
        y += int(self.square*1.1)
        # default and start button
        self.rects_defaults   = pygame.Rect(int(x+SCREEN.get_width()/5+self.square*1.5), y, self.square*3, self.square)
        self.rects_start      = pygame.Rect(int(x+SCREEN.get_width()/5+self.square*4.5), y, self.square*3, self.square)
        # ysel = 5rd row, 2nd button
        self.xsel, self.ysel = 1, 6
        self.up_down = [ ]
        self.up_img = pygame.image.load('assets/chevron_up.png')
        self.up_img = pygame.transform.scale(self.up_img, (self.square, self.square))
        self.up_down.append(self.up_img)
        self.up_img = pygame.transform.rotate(self.up_img,180)
        self.up_down.append(self.up_img)
        self.right_icon = pygame.image.load('assets/right.png')
        self.right_icon = pygame.transform.scale(self.right_icon, (self.square, self.square))
        self.wrong_icon = pygame.image.load('assets/wrong.png')
        self.wrong_icon = pygame.transform.scale(self.wrong_icon, (self.square, self.square))
        self.static_bkg_img = pygame.image.load('assets/back_cover.jpg')
        self.static_bkg_img = pygame.transform.scale(self.static_bkg_img, (SCREEN.get_width(), SCREEN.get_height()))
        self.back_img = self.static_bkg_img.copy()
        SCREEN.blit(self.background, (0, 0))
        self.background.blit(self.static_bkg_img, (0, 0))
        self.txt_rendered = []

    def start(self, *args):
        self.back_img = self.static_bkg_img.copy()
        SCREEN.blit(self.background, (0, 0))
        self.txt_rendered = [ ]
        self.background.blit(self.back_img, (0, 0))
        p_surface=pygame.Rect(SCREEN.get_width()*3/8, SCREEN.get_height()/100,
                  SCREEN.get_width()/3, SCREEN.get_height()/10)
        self.txt_rendered.append(RenderedText('SETTINGS', TEXT_COLOR, TEXT_HALO_MENU, p_surface, 4, 30))
        p_surface2=pygame.Rect(SCREEN.get_width()*3/8, SCREEN.get_height()*8/10,
                  SCREEN.get_width()/3, SCREEN.get_height()/10)
        self.txt_rendered.append(RenderedText('[HOTKEY]+[START] TO QUIT', TEXT_COLOR, TEXT_HALO_MENU, p_surface2, 4, 50))
        n = 0
        for rect in self.rects_val:
            self.txt_rendered.append(RenderedText(self.settings[n], TEXT_COLOR, TEXT_HALO_MENU, self.rects_set[n], 4, 30))
            n += 1
        for i in range(len(self.rects_gmode)):
            self.txt_rendered.append(RenderedText(GAMEMODES_NAMES[i], TEXT_COLOR, TEXT_HALO_MENU, self.rects_gmode[i], 4, 30))

    def draw(self):
        SCREEN.blit(self.background, (0, 0))
        for i, rendered in enumerate(self.txt_rendered):
            SCREEN.blit(rendered.surface, (rendered.rect.x, rendered.rect.y))
        n = 0
        for rect in self.rects_val:
            color = BOX_COLOR if (n == self.ysel and self.xsel == 0) else TEXT_HALO_MENU
            pygame.draw.rect(self.background, pygame.Color(color), self.rects_down[n], int(BOX_WIDTH*SCREEN.get_height() / 1080), border_radius=self.square//4)
            self.background.blit(self.up_down[1], (self.rects_down[n].x,self.rects_down[n].y))
            subsurface = self.static_bkg_img.subsurface(self.rects_val[n])
            self.background.blit(subsurface, (self.rects_val[n].x, self.rects_val[n].y))
            rct = pygame.Rect(self.rects_val[n].x+self.square/10, self.rects_val[n].y+self.square/3, self.square, self.square)
            value_text = RenderedText(str(self.settings_val[n]), TEXT_COLOR, TEXT_HALO_MENU, rct)
            self.background.blit(value_text.surface, (value_text.rect.x, value_text.rect.y))
            self.background.blit(self.up_down[0], (self.rects_up[n].x,self.rects_up[n].y))
            color = BOX_COLOR if (n == self.ysel and self.xsel == 1) else TEXT_HALO_MENU
            pygame.draw.rect(self.background, pygame.Color(color), self.rects_up[n], int(BOX_WIDTH*SCREEN.get_height() / 1080), border_radius=self.square//4)
            n += 1
        for i in range(2):
            ico = self.right_icon if self.settings_val[4][i] == 1 else self.wrong_icon
            subsurface = self.static_bkg_img.subsurface(self.rects_gmval[i])
            self.background.blit(subsurface, (self.rects_gmval[i].x, self.rects_gmval[i].y))
            self.background.blit(ico, (self.rects_gmval[i].x,self.rects_gmval[i].y))
            color = BOX_COLOR if (4 == self.ysel and self.xsel == i) else TEXT_HALO_MENU
            pygame.draw.rect(self.background, pygame.Color(color), self.rects_gmval[i], int(BOX_WIDTH*SCREEN.get_height() / 1080), border_radius=self.square//4)
        for i in range(3):
            ico = self.right_icon if self.settings_val[4][2+i] == 1 else self.wrong_icon
            subsurface = self.static_bkg_img.subsurface(self.rects_gmval[2+i])
            self.background.blit(subsurface, (self.rects_gmval[2+i].x, self.rects_gmval[2+i].y))
            self.background.blit(ico, (self.rects_gmval[2+i].x,self.rects_gmval[2+i].y))
            color = BOX_COLOR if (5 == self.ysel and self.xsel == i) else TEXT_HALO_MENU
            pygame.draw.rect(self.background, pygame.Color(color), self.rects_gmval[2+i], int(BOX_WIDTH*SCREEN.get_height() / 1080), border_radius=self.square//4)
        # defaults and start buttons
        color = BOX_COLOR if (6 == self.ysel and self.xsel == 0) else TEXT_HALO_MENU
        pygame.draw.rect(self.background, pygame.Color(color), self.rects_defaults,
                         int(BOX_WIDTH*SCREEN.get_height() / 1080), border_radius=self.square//4)
        rct = pygame.Rect(self.rects_defaults.x + self.square/3,
                          self.rects_defaults.y + self.square/3,
                          self.square*3, self.square)
        defaults_text = RenderedText('DEFAULTS', TEXT_COLOR, TEXT_HALO_MENU, rct)
        self.background.blit(defaults_text.surface, (defaults_text.rect.x, defaults_text.rect.y))

        color = BOX_COLOR if (6 == self.ysel and self.xsel == 1) else TEXT_HALO_MENU
        pygame.draw.rect(self.background, pygame.Color(color), self.rects_start,
                         int(BOX_WIDTH*SCREEN.get_height() / 1080), border_radius=self.square//4)
        rct = pygame.Rect(self.rects_start.x + self.square/2,
                          self.rects_defaults.y + self.square/3,
                          self.square*3, self.square)
        greylevel = int(math.sin(math.radians(pygame.time.get_ticks()/5 % 360)) * 127)
        start_text = RenderedText('START',
                                  (32+greylevel/4, 128+greylevel, 64+greylevel/2),
                                  TEXT_HALO_MENU, rct)
        self.background.blit(start_text.surface, (start_text.rect.x, start_text.rect.y))


    def action(self):
        if self.ysel == 0:
            # Number of questions
            if self.xsel == 0:
                self.settings_val[0] -= 1
                if self.settings_val[0] < 5:
                    self.settings_val[0] = 5
            elif self.xsel == 1:
                self.settings_val[0] += 1
                if self.settings_val[0] > NUM_QUESTIONS_MAX:
                    self.settings_val[0] = NUM_QUESTIONS_MAX # 50 questions max
        elif self.ysel == 1:
            # Time limit
            if self.xsel == 0:
                self.settings_val[1] -= 1
                if self.settings_val[1] < 5:
                    self.settings_val[1] = 5
            elif self.xsel == 1:
                self.settings_val[1] += 1
                if self.settings_val[1] > TIMER_MAX:
                    self.settings_val[1] = TIMER_MAX # 60 sec max
        elif self.ysel == 2:
            # Sound volume
            if self.xsel == 0:
                self.settings_val[2] -= 1
                if self.settings_val[2] < 0:
                    self.settings_val[2] = 0
            elif self.xsel == 1:
                self.settings_val[2] += 1
                if self.settings_val[2] > SOUND_VOL:
                    self.settings_val[2] = SOUND_VOL
        elif self.ysel == 3:
            # Number players
            if self.xsel == 0:
                self.settings_val[3] -= 1
                if self.settings_val[3] < 1:
                    self.settings_val[3] = 1
            elif self.xsel == 1:
                self.settings_val[3] += 1
                if self.settings_val[3] > PLAYERS_MAX:
                    self.settings_val[3] = PLAYERS_MAX # 4 players max
        elif self.ysel == 4:
            # Game mode
            for i in range(2):
                if self.xsel == i:
                    self.settings_val[4][i] = (self.settings_val[4][i]+1)%2
        elif self.ysel == 5:
            # video tricks
            for i in range(3):
                if self.xsel == i:
                    self.settings_val[4][2+i] = (self.settings_val[4][2+i]+1)%2
        elif self.ysel == 6:
            # Default and Start
            if self.xsel == 0:
                self.settings_val = [ NUMBER_Q, TIMER, SOUND_VOL, PLAYERS, GAMEMODES[:] ]
            elif self.xsel == 1:
                self.QB.number_q  = self.settings_val[0]
                self.QB.timer     = self.settings_val[1]
                self.QB.sound_vol = self.settings_val[2]
                self.QB.players   = self.settings_val[3]
                self.QB.gamemode  = self.settings_val[4]
                log(f"Number of questions: {self.QB.number_q}, timer: {self.QB.timer}, players: {self.QB.players}, sound vol: {self.QB.sound_vol}")
                log(f"Selected gamemodes: {self.QB.gamemode}")
                return ('QUIZ', GameState(self.QB))

    def update(self, events, dt):
        for event in events:
            if key_pressed(event, JOYSTICKS)[1] == 'up':
                self.ysel = (self.ysel-1) % (len(self.settings)+2)
                if (self.ysel !=5) and (self.xsel > 1):
                    self.xsel = 1
            elif key_pressed(event, JOYSTICKS)[1] == 'left':
                if (self.ysel == 4):
                    self.xsel = (self.xsel-1) % 2 # 2 options on this line
                elif (self.ysel == 5):
                    self.xsel = (self.xsel-1) % 3 # 3 options on this line
                else:
                    self.xsel = (self.xsel-1) % 2
            elif key_pressed(event, JOYSTICKS)[1] == 'right':
                if (self.ysel == 4):
                    self.xsel = (self.xsel+1) % 2 # 2 options on this line
                elif (self.ysel == 5):
                    self.xsel = (self.xsel+1) % 3 # 3 options on this line
                else:
                    self.xsel = (self.xsel+1) % 2
            elif key_pressed(event, JOYSTICKS)[1] == 'down':
                self.ysel = (self.ysel+1) % (len(self.settings)+2)
                if (self.ysel != 5) and (self.xsel > 1):
                    self.xsel = 1
            elif key_pressed(event, JOYSTICKS)[1] == 'action':
                return self.action()

######################################
### Larger countdown
def circlepoints(r, ccache):
    r = int(round(r))
    if r in ccache:
        return ccache[r]
    x, y, e = r, 0, 1 - r
    ccache[r] = points = []
    while x >= y:
        points.append((x, y))
        y += 1
        if e < 0:
            e += 2 * y - 1
        else:
            x -= 1
            e += 2 * (y - x) - 1
    points += [(y, x) for x, y in points if x > y]
    points += [(-x, y) for x, y in points if x]
    points += [(x, -y) for x, y in points if y]
    points.sort()
    return points

class Timer(pygame.sprite.Sprite):
    circle_cache = {}

    def __init__(self):
        pygame.sprite.Sprite.__init__(self)
        self.image = None
        self.font = pygame.font.Font(SYS_FONT, 5 * int(FONT_SIZE*SCREEN.get_height()/1080))

    def update (self, passed_time, max_timer, opx=8):
        # Larger font for the timer
        opx=opx*SCREEN.get_height()//1080
        font_color = pygame.Color(TIMER_COLOR_END) if passed_time <= 5 else pygame.Color(TIMER_COLOR)
        text = str(passed_time if passed_time < max_timer else max_timer)
        textsurface = self.font.render(text, True, font_color).convert_alpha()
        w = textsurface.get_width() + 2 * opx
        h = self.font.get_height()
        osurf = pygame.Surface((w, h + 2 * opx)).convert_alpha()
        osurf.fill((0, 0, 0, 0))
        surf = osurf.copy()
        osurf.blit(self.font.render(text, True, TEXT_HALO_TIMER).convert_alpha(), (0, 0))
        for dx, dy in circlepoints(opx, self.circle_cache):
            surf.blit(osurf, (dx + opx, dy + opx))
        surf.blit(textsurface, (opx, opx))
        self.image = surf
        self.rect = (int(SCREEN.get_width()*0.8), int(SCREEN.get_height()*0.15))

######################################
### Quizz Game Scene
class QuizScreen:
    def __init__(self):
        self.square = int(SCREEN.get_height()/10)
        self.background = pygame.Surface((SCREEN.get_width(), SCREEN.get_height()))
        self.right_icon = pygame.image.load('assets/right.png')
        self.right_icon = pygame.transform.scale(self.right_icon, (self.square, self.square))
        self.wrong_icon = pygame.image.load('assets/wrong.png')
        self.wrong_icon = pygame.transform.scale(self.wrong_icon, (self.square, self.square))
        self.static_bkg_img = pygame.image.load('assets/back_q.jpg')
        self.static_bkg_img = pygame.transform.scale(self.static_bkg_img, (SCREEN.get_width(), SCREEN.get_height()))
        self.scorefont = pygame.font.Font(SYS_FONT, int(FONT_SIZE*SCREEN.get_height()/1080))
        self.back_img = self.static_bkg_img.copy()
        self.background.blit(self.back_img, (0, 0))
        self.q_surface = None
        self.vsprite = None
        self.vsprite_group = None
        self.reveal = False
        self.rects = []
        self.resps = []
        x = int(10 + SCREEN.get_width()/20)
        y = int(SCREEN.get_height()/2 + self.square)
        self.arrows = [ ]
        self.arrow_img = pygame.image.load('assets/arrow.png')
        self.arrow_img = pygame.transform.scale(self.arrow_img, (self.square, self.square))
        self.arrows.append(self.arrow_img)
        for i in range (3):
            self.arrow_img = pygame.transform.rotate(self.arrow_img,90)
            self.arrows.append(self.arrow_img)
        ricox = [ int(x + SCREEN.get_width()*0.8 /2 /2),
                      int(x),
                      int(x + SCREEN.get_width()*0.8 /2 /2),
                      int(x + SCREEN.get_width()*0.8 /2) ]
        ricoy = [ int(y),
                      int(y + int(self.square*1.1)),
                      int(y + 2*int(self.square*1.1)),
                      int(y + int(self.square*1.1)) ]
        self.small_arrows = []
        for img in self.arrows:
            timg = pygame.transform.scale(img, (self.square//2, self.square//2))
            self.small_arrows.append(timg)
        readyimg = pygame.image.load('assets/ready.png')
        self.small_ready = pygame.transform.scale(readyimg, (int(self.square/1.5), self.square//2))
        for n in range(4):
            rect = pygame.Rect(ricox[n], ricoy[n], self.square, self.square)
            resp = pygame.Rect(int(ricox[n]+self.square*1.2), int(ricoy[n]+self.square*0.2), int(SCREEN.get_width()*0.8/2-self.square*1.2), self.square)
            self.rects.append(rect)
            self.resps.append(resp)
        self.countdown = Timer()
        self.sound_manager = SoundManager()
        self.reveal = False
        self.pulse_val = 0
    log ("Initialized QuizScreen")

    def start(self, gamestate):
        self.gamestate = gamestate
        self.sound_manager.volume(gamestate.QB.sound_vol)
        self.r = [ ]
        self.txt_rendered = [ ]
        for n in range(5):
            self.r.append('')
        self.question, self.answer, self.r[1], self.r[2], self.r[3], self.r[4] = gamestate.pop_question()
        self.is_video = any(self.question.lower().endswith(ext) for ext in VIDEO_EXTENSIONS)
        # Clean and draw question
        if self.vsprite_group is not None:
            if self.vsprite is not None:
                self.vsprite_group.remove(self.vsprite)
                self.vsprite = None
            self.vsprite_group = None
        self.q_surface = pygame.Rect(int(self.square*2.2), int(self.square/4),
            int((SCREEN.get_height()/2.1+self.square*3/5)*(4/3)), int(SCREEN.get_height()/2.1+self.square*3/5))

        if self.is_video:
            # Surface video player
            if self.gamestate.current_mode == 2:
                mode = "pixelated"
            elif self.gamestate.current_mode == 3:
                mode = "rotated"
            elif self.gamestate.current_mode == 4:
                mode = "zoom"
            else:
                mode = "regular"
            self.vsprite = videoplayer.VideoSprite(self.q_surface, self.question, self.sound_manager, mode)
            self.vsprite_group = pygame.sprite.Group()
            self.vsprite_group.add(self.vsprite)
        else:
            self.vsprite = None
            self.vsprite_group = None
        self.contsurf = pygame.Rect(int(SCREEN.get_width()*0.8), int(SCREEN.get_height()*0.82),
                                int(SCREEN.get_width()*0.2), int(SCREEN.get_height()*0.18))
        self.timer_started = True
        self.start_time = pygame.time.get_ticks() + gamestate.QB.timer * 1000 + 950 # margin to draw screen
        self.passed_time = self.start_time
        self.reveal = False
        self.vinput = [ 0, 0, 0, 0 ]
        self.ready  = [ 0, 0, 0, 0 ]
        self.back_img = self.static_bkg_img.copy()
        SCREEN.blit(self.background, (0, 0))
        self.txt_rendered = [ ]
        if not self.is_video:
            q_surf_text = self.q_surface
            q_surf_text[1] = int(self.square/2)
            self.txt_rendered.append(RenderedText(self.question, TEXT_COLOR, TEXT_HALO, q_surf_text))
        self.countdown_list = pygame.sprite.Group()
        self.countdown_list.add(self.countdown)
        for i in range(1, 5):
            box_rect = self.resps[i-1]
            self.txt_rendered.append(RenderedText(self.r[i], TEXT_COLOR, TEXT_HALO, box_rect))
        rct = pygame.Rect(int(SCREEN.get_width()*0.8), int(SCREEN.get_height()*0.4),
                  int(SCREEN.get_width()*0.2), int(self.square//2))
        self.txt_rendered.append(RenderedText('SCORE BOARD:', TEXT_COLOR, TEXT_HALO, rct))
        rct = pygame.Rect((int(SCREEN.get_width()*0.8), int(SCREEN.get_height()*0.05),
                  int(SCREEN.get_width()*0.2), int(SCREEN.get_height()*0.10)))
        self.txt_rendered.append(RenderedText(f"QUESTION: {self.gamestate.numq}/{self.gamestate.QB.number_q}", TEXT_COLOR, TEXT_HALO, rct))

    def draw(self):
        self.background.blit(self.back_img, (0, 0))
        SCREEN.blit(self.background, (0, 0))
        for i, rendered in enumerate(self.txt_rendered):
            SCREEN.blit(rendered.surface, (rendered.rect.x, rendered.rect.y))
        n = 1
        for rect in self.rects:
            # Color boxes
            col      = BOX_COLOR
            wid      = BOX_WIDTH
            self.back_img.blit(self.arrows[n-1], (rect.x, rect.y))
            if self.reveal:
                for p in range(self.gamestate.QB.players):
                    if n == self.vinput[p]:
                        pygame.draw.rect(self.back_img, pygame.Color(TEXT_COLOR), rect, 0, border_radius=self.square//4) # 0 = fill
                        ico = colorize_icon(self.wrong_icon, pygame.Color(BOX_COLOR_WRONG))
                        self.back_img.blit(ico, (rect.x, rect.y))
                    if n == self.answer:
                        pygame.draw.rect(self.back_img, pygame.Color(TEXT_COLOR), rect, 0, border_radius=self.square//4) # 0 = fill
                        ico = colorize_icon(self.right_icon, pygame.Color(BOX_COLOR_ANSWER))
                        self.back_img.blit(ico, (rect.x, rect.y))
            n += 1
        # Timer and scores
        subsurface = self.static_bkg_img.subsurface((int(SCREEN.get_width()*0.8),0,int(SCREEN.get_width()*0.2),SCREEN.get_height()*0.7))
        self.back_img.blit(subsurface, (int(SCREEN.get_width()*0.8), 0))
        # Video player (except if Trivia)
        if self.is_video:
            subsurface2 = self.static_bkg_img.subsurface(0,0,int(SCREEN.get_width()*0.8),int(SCREEN.get_height()/2.1+self.square))
            self.back_img.blit(subsurface2, (0, 0))
        all_answered = 1
        if self.reveal:
            cont_text = "Everyone, " if self.gamestate.QB.players>1 else "Player 1, "
            cont_text += "\n press [A]\n  to continue"
            greylevel = self.pulse_val
            cont_rtext = RenderedText(cont_text, (32+greylevel/4, 128+greylevel, 64+greylevel/2),
                                  TEXT_HALO, self.contsurf, 1, 20)
            SCREEN.blit(cont_rtext.surface, (cont_rtext.rect.x, cont_rtext.rect.y))
        scorey= int(SCREEN.get_height()*0.4)
        for p in range(self.gamestate.QB.players):
            reponse     = pygame.Surface((0, 0))
            surfreponse = pygame.Rect(0, 0, 0, 0)
            ready       = pygame.Surface((0, 0))
            scorey += int(self.square*0.5)
            if self.reveal:
                if self.vinput[p] == 1:
                    reponse = self.small_arrows[0]
                    surfreponse = pygame.Rect(int(SCREEN.get_width()*0.9), scorey, self.square//2, self.square//2)
                elif self.vinput[p] == 2:
                    reponse = self.small_arrows[1]
                    surfreponse = pygame.Rect(int(SCREEN.get_width()*0.9), scorey, self.square//2, self.square//2)
                elif self.vinput[p] == 3:
                    reponse = self.small_arrows[2]
                    surfreponse = pygame.Rect(int(SCREEN.get_width()*0.9), scorey, self.square//2, self.square//2)
                elif self.vinput[p] == 4:
                    reponse = self.small_arrows[3]
                    surfreponse = pygame.Rect(int(SCREEN.get_width()*0.9), scorey, self.square//2, self.square//2)
            ready = self.small_ready if self.ready[p] else pygame.Surface((0,0))
            rct = pygame.Rect(int(SCREEN.get_width()*0.8), int(scorey+(self.square/10)),
                  int(SCREEN.get_width()*0.2), int(self.square//2))
            score_text = RenderedText(f"P{p+1}: {self.gamestate.score[p]}", TEXT_COLOR, TEXT_HALO, rct)
            SCREEN.blit(score_text.surface, (score_text.rect.x, score_text.rect.y))

            greylevel = int(math.sin(math.radians(pygame.time.get_ticks()/2%360))*63)
            if self.vinput[p] == self.answer:
                reponse = colorize_icon(reponse, pygame.Color(BOX_COLOR_ANSWER))
                small_rect_color = (0, 64+greylevel, 0)
            else:
                reponse = colorize_icon(reponse, pygame.Color(BOX_COLOR_WRONG))
                small_rect_color = (0, 0, 0)
            pygame.draw.rect(self.back_img, small_rect_color, surfreponse, 0, border_radius=self.square//8) # 0 = fill
            self.back_img.blit(reponse, (int(SCREEN.get_width()*0.9), scorey))
            self.back_img.blit(ready, (int(SCREEN.get_width()*0.93), scorey))
        self.countdown_list.update(int(self.passed_time/1000), self.gamestate.QB.timer)
        self.countdown_list.draw(self.back_img)
        if self.vsprite_group is not None:
             self.vsprite_group.update(int(self.passed_time/1000), self.gamestate.QB.timer)
             self.vsprite_group.draw(self.back_img)

    def update(self, events, dt):
        self.pulse_val = int(math.sin(math.radians(pygame.time.get_ticks()/5%360))*127)
        if self.reveal == False :
            self.passed_time = self.start_time - pygame.time.get_ticks()
            for event in events:
                if self.gamestate.numqansw >= self.gamestate.numq:
                    break
                if self.reveal == False:
                    (p, ev) = key_pressed (event, JOYSTICKS)
                    if ev == 'up':
                        self.vinput[p] = 1
                        self.gamestate.QB.timerplayers[p] = int(self.passed_time/1000
                            if self.passed_time/1000 < self.gamestate.QB.timer else self.gamestate.QB.timer)
                    elif ev == 'left':
                        self.vinput[p] = 2
                        self.gamestate.QB.timerplayers[p] = int(self.passed_time/1000
                            if self.passed_time/1000 < self.gamestate.QB.timer else self.gamestate.QB.timer)
                    elif ev == 'right':
                        self.vinput[p] = 4
                        self.gamestate.QB.timerplayers[p] = int(self.passed_time/1000
                            if self.passed_time/1000 < self.gamestate.QB.timer else self.gamestate.QB.timer)
                    elif ev == 'down':
                        self.vinput[p] = 3
                        self.gamestate.QB.timerplayers[p] = int(self.passed_time/1000
                            if self.passed_time/1000 < self.gamestate.QB.timer else self.gamestate.QB.timer)
                all_answered = 1
                for p in range(self.gamestate.QB.players):
                    all_answered *= self.vinput[p]
                if all_answered:
                    res = self.gamestate.get_answer(self.vinput, self.gamestate.QB.timerplayers)
                    if self.gamestate.QB.sound_vol > 0:
                       if res:
                           self.sound_manager.play('assets/playerright.wav')
                       else:
                           self.sound_manager.play('assets/playeranswered.wav')
                    self.reveal = True
                    log("Reveal answer")
            if (self.passed_time <= 0):
                self.passed_time = 0
                self.reveal = True
                log("Time's up")
                self.sound_manager.play('assets/timeout.wav')
        else:
            try:
                if self.vsprite_group is not None:
                    if self.vsprite is not None:
                        if self.vsprite.video_stop is False:
                            log ("Stop video sprite")
                            self.vsprite.stop()
            except:
                log ("Error while killing video sprite")
                pass
            for event in events:
                ev = key_pressed (event, JOYSTICKS)
                all_ready = 1
                if ev[1] == 'action':
                    self.ready[ev[0]] = 1
                    for p in range(self.gamestate.QB.players):
                        all_ready *= self.ready[p]
                    if all_ready:
                        log ("Next screen")
                        if self.gamestate.numq < self.gamestate.QB.number_q:
                           return ('QUIZ', self.gamestate)
                        else:
                            score = self.gamestate.get_result()
                            del self.gamestate # Reset for next game
                            return ('RESULT', score)
            return None

#######################################
### Main Loop
def main():
    global FONT
    global SCREEN
    global JOYSTICKS
    global LOGGER
    global PLAYERS_MAX
    LOGGER.setLevel(logging.DEBUG)
    loghandler = logging.StreamHandler(sys.stderr)
    logformat = logging.Formatter('[%(asctime)s] %(message)s')
    loghandler.setFormatter(logformat)
    LOGGER.addHandler(loghandler)
    os.environ['SDL_AUDIODRIVER'] = 'alsa'
    pygame.mouse.set_visible(0)
    infoObject = pygame.display.Info()
    SCREEN = pygame.display.set_mode((infoObject.current_w, infoObject.current_h), WINDOW_SURFACE)
    log(f"Game screen: {SCREEN.get_width()}x{SCREEN.get_height()}")
    pygame.font.init()
    if FONT == None:
        FONT = pygame.freetype.Font(SYS_FONT, int(FONT_SIZE*SCREEN.get_height()/1080))
    pygame.joystick.init()
    njoy = pygame.joystick.get_count()
    log(f"Number of joysticks found: {njoy}")
    for i in range(njoy):
        JOYSTICKS[i] = pygame.joystick.Joystick(i)
        JOYSTICKS[i].init()
        log(f"Joystick {i} initialized as {pygame.joystick.Joystick(i).get_guid()} - \
             {pygame.joystick.Joystick(i).get_instance_id()}")
    PLAYERS_MAX = njoy if njoy <= PLAYERS_MAX else PLAYERS_MAX
    if PLAYERS_MAX == 0:
        PLAYERS_MAX = 1
    clock = pygame.time.Clock()
    dt = 0
    scenes =  {'TITLE'   : StaticScreen('SETTINGS', 'assets/logo.png',''),}
    scene = scenes['TITLE']
    scene.start(None)
    starttime = pygame.time.get_ticks()
    scene.draw()
    pygame.display.flip()
    scene.initialize_QB()
    while scene.QB.loaded_pcent < 100:
        scene.additional(f"\n\nLOADING GAMES: {scene.QB.loaded_pcent}%")
        scene.draw()
        pygame.display.flip()
        dt = clock.tick(60)
        pygame.time.wait(100) # 100ms
    delta = (pygame.time.get_ticks() - starttime) // 1000
    scene.additional("")
    scene.start(f"\n\n\n\n{scene.QB.loaded} QUESTIONS\nLOADED IN {delta} SEC\n \nPlayer 1 Press [A] to start\n \n[HOTKEY]+[START] to quit")
    scenes.update({
        'SETTINGS': SettingsScreen(scene.QB),
        'QUIZ'    : QuizScreen(),
        'RESULT'  : StaticScreen('TITLE', 'assets/score.png', ''),
    })
    while True:
        events = pygame.event.get(pump=True)
        for e in events:
            if e.type == pygame.QUIT:
                return
            try:
                if JOYSTICKS[0] and JOYSTICKS[0].get_button(12) and JOYSTICKS[0].get_button(17): # hotkey + start for player 1 only
                    return
            except:
                pass
        result = scene.update(events, dt)
        if result:
            next_scene, state = result
            if next_scene:
                scene = scenes[next_scene]
                scene.start(state)
        scene.draw()
        pygame.display.flip()
        dt = clock.tick(60)

if __name__ == '__main__':
    pygame.init()
    main()
